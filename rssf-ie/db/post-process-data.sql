-- 1. Export team names to post-process with Google Refine

SELECT NAME,COUNTRY,ID,NAME NAME_DUP,COUNTRY COUNTRY_DUP 
FROM TEAM;

-- 2. Import stage name with transformed deduplicated team names, create an stage table and insert data 
drop table TEAM_DEDUP;

CREATE TABLE TEAM_DEDUP (
		NAME VARCHAR(50) NOT NULL,
		COUNTRY VARCHAR(3),
		ID_DUP INTEGER NOT NULL,
		NAME_DUP VARCHAR(50) NOT NULL,
		COUNTRY_DUP VARCHAR(3)
);

-- Insert data from team-dedup-insert.sql

-- 3. Create table with unique names and reindex 
CREATE TABLE TEAM_CLEAN (
		ID INTEGER NOT NULL GENERATED ALWAYS AS IDENTITY (START WITH 1, INCREMENT BY 1),
		NAME VARCHAR(50) NOT NULL,
		COUNTRY VARCHAR(3),
		CONSTRAINT team_unique_pk PRIMARY KEY (ID),
		CONSTRAINT team_unique_uk UNIQUE(NAME,COUNTRY)
);
 
INSERT INTO TEAM_CLEAN(NAME,COUNTRY)
SELECT DISTINCT NAME,COUNTRY 
FROM TEAM_DEDUP;

 
CREATE TABLE TEAM_MAP (
	ID_NEW INTEGER NOT NULL,
	ID_OLD INTEGER NOT NULL,
	CONSTRAINT team_map_pk PRIMARY KEY (ID_NEW, ID_OLD),
	CONSTRAINT team_map_uk UNIQUE (ID_OLD)
)
	
	
INSERT INTO TEAM_MAP(ID_NEW, ID_OLD)
SELECT TEAM_CLEAN.ID, TEAM_DEDUP.ID_DUP
FROM TEAM_CLEAN, TEAM_DEDUP
WHERE TEAM_CLEAN.NAME = TEAM_DEDUP.NAME AND TEAM_CLEAN.COUNTRY = TEAM_DEDUP.COUNTRY;


-- 6. Reindex MATCH_PAIR to dedup data

DROP TABLE MATCH_PAIR_CLEAN;

CREATE TABLE MATCH_PAIR_CLEAN (
      id INTEGER NOT NULL,
      team1 INTEGER NOT NULL,
      team2 INTEGER NOT NULL,
      leg1_1 INTEGER NOT NULL,
      leg1_2 INTEGER NOT NULL,
      leg2_1 INTEGER NOT NULL,
      leg2_2 INTEGER NOT NULL,
      total1 INTEGER NOT NULL,
      total2 INTEGER NOT NULL,
      competition INTEGER NOT NULL,
      phase VARCHAR(50) NOT NULL,
      uri VARCHAR(80), 
      CONSTRAINT match_pair_clean_pk PRIMARY KEY (id),
      CONSTRAINT match_pair_clean_phase_fk FOREIGN KEY (competition,phase) REFERENCES PHASE(competition,name),
      CONSTRAINT match_pair_clean_team1_fk FOREIGN KEY (team1) REFERENCES TEAM_CLEAN(id),
      CONSTRAINT match_pair_clean_team2_fk FOREIGN KEY (team2) REFERENCES TEAM_CLEAN(id)
);


INSERT INTO MATCH_PAIR_CLEAN(id, team1, team2, leg1_1, leg1_2, leg2_1, leg2_2, total1, total2, competition, phase, uri)
SELECT MATCH_PAIR.ID, T1.ID_NEW, T2.ID_NEW, LEG1_1, LEG2_1, LEG2_1, LEG2_2, TOTAL1, TOTAL2, COMPETITION, PHASE, URI
FROM (MATCH_PAIR JOIN TEAM_MAP T1 ON MATCH_PAIR.TEAM1 = T1.ID_OLD)  
JOIN TEAM_MAP T2 ON MATCH_PAIR.TEAM2 = T2.ID_OLD

-- 7. Reindex MATCH_SINGLE to dedup data 

DROP TABLE MATCH_SINGLE_CLEAN;

CREATE TABLE MATCH_SINGLE_CLEAN (
    		id INTEGER NOT NULL,
       		team1 INTEGER NOT NULL,
       		team2 INTEGER NOT NULL,
       		result1 INTEGER NOT NULL,
       		result2 INTEGER NOT NULL,
       		mid1 INTEGER,
       		mid2 INTEGER,
       		competition INTEGER NOT NULL,
       		phase VARCHAR(50) NOT NULL,
       		uri VARCHAR(80), 
       		CONSTRAINT match_single_clean_pk PRIMARY KEY (id),
       		CONSTRAINT match_single_clean_phase_fk FOREIGN KEY (competition,phase) REFERENCES PHASE(competition,name),
       		CONSTRAINT match_single_clean_team1_fk FOREIGN KEY (team1) REFERENCES TEAM(id),
       		CONSTRAINT match_single_clean_team2_fk FOREIGN KEY (team2) REFERENCES TEAM(id)
);

INSERT INTO MATCH_SINGLE_CLEAN (id, team1, team2, result1, result2, mid1, mid2, competition, phase, uri)
SELECT M.ID, T1.ID_NEW, T2.ID_NEW, M.RESULT1, M.RESULT2, M.MID1, M.MID2, M.COMPETITION, M.PHASE, M.URI
FROM (MATCH_SINGLE M JOIN TEAM_MAP T1 ON M.TEAM1 = T1.ID_OLD)
JOIN TEAM_MAP T2 ON M.TEAM2 = T2.ID_OLD;

-- 8. Generate match_pair winners
DROP TABLE MATCH_PAIR_RESULTS;

CREATE TABLE MATCH_PAIR_RESULTS (
      id INTEGER NOT NULL,
      winner INTEGER NOT NULL
)

INSERT INTO MATCH_PAIR_RESULTS (ID, WINNER)
SELECT ID, 0
FROM MATCH_PAIR_CLEAN
WHERE TOTAL1 > TOTAL2
UNION ALL
SELECT ID, 1
FROM MATCH_PAIR_CLEAN
WHERE TOTAL1 < TOTAL2

-- Eliminatorias acabadas en empate
SELECT COUNT(*)
FROM MATCH_PAIR_CLEAN
WHERE TOTAL1 = TOTAL2


SELECT MA.ID, TEAM1, TEAM2, MA.COMPETITION, PHASE, NUM 
FROM MATCH_PAIR_CLEAN MA JOIN PHASE PA 
ON MA.COMPETITION = PA.COMPETITION
AND MA.PHASE = PA.NAME
WHERE TOTAL1 = TOTAL2


INSERT INTO MATCH_PAIR_RESULTS (ID, WINNER)
-- Eliminatorias empatadas que por partidos posteriores se deduce que ha ganado el equipo de casa
-- a partir de los datos de eliminatorias posteriores
SELECT DISTINCT E.id, 0
FROM (MATCH_PAIR_CLEAN E JOIN PHASE PE ON E.COMPETITION = PE.COMPETITION AND E.PHASE = PE.NAME), 
(MATCH_PAIR_CLEAN MA JOIN PHASE PA ON MA.COMPETITION = PA.COMPETITION AND MA.PHASE = PA.NAME)
WHERE E.TOTAL1 = E.TOTAL2
AND MA.COMPETITION = E.COMPETITION AND PA.NUM > PE.NUM
AND (MA.TEAM1 = E.TEAM1 OR MA.TEAM2 = E.TEAM1)
UNION 
-- Eliminatorias empatadas que por partidos posteriores se deduce que ha ganado el equipo de casa
-- a partir de partidos individuales
SELECT E.id, 0
FROM (MATCH_PAIR_CLEAN E JOIN PHASE PE ON E.COMPETITION = PE.COMPETITION AND E.PHASE = PE.NAME), 
(MATCH_SINGLE_CLEAN MA JOIN PHASE PA ON MA.COMPETITION = PA.COMPETITION AND MA.PHASE = PA.NAME)
WHERE E.TOTAL1 = E.TOTAL2
AND MA.COMPETITION = E.COMPETITION AND PA.NUM > PE.NUM
AND (MA.TEAM1 = E.TEAM1 OR MA.TEAM2 = E.TEAM1)
UNION 
-- Eliminatorias empatadas que por partidos posteriores se deduce que ha ganado el equipo de fuera
-- a partir de los datos de eliminatorias posteriores
SELECT DISTINCT E.id, 1 
FROM (MATCH_PAIR_CLEAN E JOIN PHASE PE ON E.COMPETITION = PE.COMPETITION AND E.PHASE = PE.NAME), 
(MATCH_PAIR_CLEAN MA JOIN PHASE PA ON MA.COMPETITION = PA.COMPETITION AND MA.PHASE = PA.NAME)
WHERE E.TOTAL1 = E.TOTAL2
AND MA.COMPETITION = E.COMPETITION AND PA.NUM > PE.NUM
AND (MA.TEAM1 = E.TEAM2 OR MA.TEAM2 = E.TEAM2)
UNION 
-- Eliminatorias empatadas que por partidos posteriores se deduce que ha ganado el equipo de fuera
-- a partir de partidos individuales
SELECT DISTINCT E.id, 1
FROM (MATCH_PAIR_CLEAN E JOIN PHASE PE ON E.COMPETITION = PE.COMPETITION AND E.PHASE = PE.NAME), 
(MATCH_SINGLE_CLEAN MA JOIN PHASE PA ON MA.COMPETITION = PA.COMPETITION AND MA.PHASE = PA.NAME)
WHERE E.TOTAL1 = E.TOTAL2
AND MA.COMPETITION = E.COMPETITION AND PA.NUM > PE.NUM
AND (MA.TEAM1 = E.TEAM2 OR MA.TEAM2 = E.TEAM2)

-- Show results 
SELECT ID, COUNT(*)
FROM MATCH_PAIR_RESULTS
GROUP BY ID
HAVING COUNT(*) > 1

-- 8. Generate semifinalist by season
CREATE TABLE SEMIFINALIST (
	competition INTEGER NOT NULL,
    team INTEGER NOT NULL,
	CONSTRAINT semifinalist_pk PRIMARY KEY (competition,team),
    CONSTRAINT semifinalist_competition_fk FOREIGN KEY (competition) REFERENCES COMPETITION(id)
)

INSERT INTO SEMIFINALIST(COMPETITION, TEAM)
SELECT COMPETITION, TEAM1 TEAM 
FROM MATCH_PAIR_CLEAN
WHERE PHASE = 'Semi-Finals'
UNION ALL 
SELECT COMPETITION, TEAM2 TEAM 
FROM MATCH_PAIR_CLEAN
WHERE PHASE = 'Semi-Finals'
ORDER BY COMPETITION, TEAM


-- 9. Calcular potencial por pais
DROP TABLE COUNTRY_POTENTIAL;

CREATE TABLE COUNTRY_POTENTIAL (
	season VARCHAR(50),
	start INTEGER,
	country VARCHAR(50),
	num INTEGER
)

INSERT INTO COUNTRY_POTENTIAL(SEASON, START, COUNTRY, NUM)
SELECT SEASON, START, COUNTRY, COUNT(*) NUM 
FROM
(
SELECT SEASON, START, T1.COUNTRY COUNTRY
FROM 
(MATCH_PAIR_CLEAN M JOIN COMPETITION ON COMPETITION.ID = M.COMPETITION)
JOIN TEAM T1 ON T1.ID = M.TEAM1
WHERE M.PHASE = 'Semi-Finals'
UNION ALL
SELECT SEASON, START, T2.COUNTRY COUNTRY
FROM 
(MATCH_PAIR_CLEAN M JOIN COMPETITION ON COMPETITION.ID = M.COMPETITION)
JOIN TEAM T2 ON T2.ID = M.TEAM2
WHERE M.PHASE = 'Semi-Finals'
) AS SF
GROUP BY SEASON, COUNTRY, START
ORDER BY START ASC,NUM DESC;


-- 10. Calcular variables dicotÃ³micas para los resultados
CALL SQLJ.REMOVE_JAR('APP.MyDerbyUtils', 0);
CALL SQLJ.INSTALL_JAR('/home/cdepablo/tmp/rssf/myDerbyUtils.jar', 'APP.MyDerbyUtils', 0);

CALL SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY('derby.database.classpath', 'APP.MyDerbyUtils')


CREATE FUNCTION TO_INTEGER
( BOOLEANV BOOLEAN )
RETURNS INTEGER
PARAMETER STYLE JAVA
NO SQL LANGUAGE JAVA
EXTERNAL NAME 'com.seemla.rssf.db.Utils.toInt'

DROP TABLE HOME_RESULTS_MATRIX;

CREATE TABLE HOME_RESULTS_MATRIX (
 ID INTEGER NOT NULL,
 R0_0 INTEGER NOT NULL,
 R1_0 INTEGER NOT NULL,
 R2_0 INTEGER NOT NULL,
 R3_0 INTEGER NOT NULL,
 R4_0a INTEGER NOT NULL,
 R0_1 INTEGER NOT NULL,
 R0_2 INTEGER NOT NULL,
 R0_3 INTEGER NOT NULL,
 R0_4a INTEGER NOT NULL,
 R1_1 INTEGER NOT NULL,
 R2_2 INTEGER NOT NULL,
 R3_3A INTEGER NOT NULL,
 R2_1 INTEGER NOT NULL,
 R3_1 INTEGER NOT NULL,
 R4_1 INTEGER NOT NULL,
 R5_1a INTEGER NOT NULL,
 R3_2 INTEGER NOT NULL,
 R4_2 INTEGER NOT NULL,
 R5_2 INTEGER NOT NULL,
 R6_2a INTEGER NOT NULL,
 R4_3 INTEGER NOT NULL,
 R5_3 INTEGER NOT NULL,
 R6_3 INTEGER NOT NULL,
 R7_3a INTEGER NOT NULL,
 R1_2 INTEGER NOT NULL,
 R1_3 INTEGER NOT NULL,
 R1_4 INTEGER NOT NULL,
 R1_5a INTEGER NOT NULL,
 R2_3 INTEGER NOT NULL,
 R2_4 INTEGER NOT NULL,
 R2_5 INTEGER NOT NULL,
 R2_6a INTEGER NOT NULL,
 R3_4 INTEGER NOT NULL,
 R3_5 INTEGER NOT NULL,
 R3_6 INTEGER NOT NULL,
 R3_7 INTEGER NOT NULL,
 R4a_3a INTEGER NOT NULL,
 R3a_4a INTEGER NOT NULL
)


INSERT INTO HOME_RESULTS_MATRIX (
 ID,
 R0_0, R1_0, R2_0, R3_0, R4_0a, R0_1, R0_2, R0_3, R0_4a, 
 R1_1, R2_2, R3_3a, 
 R2_1, R3_1, R4_1, R5_1a,
 R3_2, R4_2, R5_2, R6_2a,
 R4_3, R5_3, R6_3, R7_3a,
 R1_2, R1_3, R1_4, R1_5a,
 R2_3, R2_4, R2_5, R2_6a,
 R3_4, R3_5, R3_6, R3_7,
 R4a_3a, R3a_4a
)
SELECT ID, 
TO_INTEGER(LEG1_1 = 0 AND LEG1_2 = 0) R0_0,
TO_INTEGER(LEG1_1 = 1 AND LEG1_2 = 0) R1_0,
TO_INTEGER(LEG1_1 = 2 AND LEG1_2 = 0) R2_0,
TO_INTEGER(LEG1_1 = 3 AND LEG1_2 = 0) R3_0,
TO_INTEGER(LEG1_1 > 3 AND LEG1_2 = 0) R4_0a,
TO_INTEGER(LEG1_1 = 0 AND LEG1_2 = 1) R0_1,
TO_INTEGER(LEG1_1 = 0 AND LEG1_2 = 2) R0_2,
TO_INTEGER(LEG1_1 = 0 AND LEG1_2 = 3) R0_3,
TO_INTEGER(LEG1_1 = 0 AND LEG1_2 > 3) R0_4a,
TO_INTEGER(LEG1_1 = 1 AND LEG1_2 = 1) R1_1,
TO_INTEGER(LEG1_1 = 2 AND LEG1_2 = 2) R2_2,
TO_INTEGER(LEG1_1 > 2 AND LEG1_2 > 2 AND LEG1_1 = LEG1_2) R3_3a,
TO_INTEGER(LEG1_1 = 2 AND LEG1_2 = 1) R2_1,
TO_INTEGER(LEG1_1 = 3 AND LEG1_2 = 1) R3_1,
TO_INTEGER(LEG1_1 = 4 AND LEG1_2 = 1) R4_1,
TO_INTEGER(LEG1_1 > 5 AND LEG1_2 = 1) R5_1a,
TO_INTEGER(LEG1_1 = 3 AND LEG1_2 = 2) R3_2,
TO_INTEGER(LEG1_1 = 4 AND LEG1_2 = 2) R4_2,
TO_INTEGER(LEG1_1 = 5 AND LEG1_2 = 2) R5_2,
TO_INTEGER(LEG1_1 > 5 AND LEG1_2 = 2) R6_2a,
TO_INTEGER(LEG1_1 = 4 AND LEG1_2 = 3) R4_3,
TO_INTEGER(LEG1_1 = 5 AND LEG1_2 = 3) R5_3,
TO_INTEGER(LEG1_1 = 6 AND LEG1_2 = 3) R6_3,
TO_INTEGER(LEG1_1 > 7 AND LEG1_2 = 3) R7_3a,
TO_INTEGER(LEG1_1 = 1 AND LEG1_2 = 2) R1_2,
TO_INTEGER(LEG1_1 = 1 AND LEG1_2 = 3) R1_3,
TO_INTEGER(LEG1_1 = 1 AND LEG1_2 = 4) R1_4,
TO_INTEGER(LEG1_1 = 1 AND LEG1_2 > 4) R1_5a,
TO_INTEGER(LEG1_1 = 2 AND LEG1_2 = 3) R2_3,
TO_INTEGER(LEG1_1 = 2 AND LEG1_2 = 4) R2_4,
TO_INTEGER(LEG1_1 = 2 AND LEG1_2 = 5) R2_5,
TO_INTEGER(LEG1_1 = 2 AND LEG1_2 > 5) R2_6a,
TO_INTEGER(LEG1_1 = 3 AND LEG1_2 = 4) R3_4,
TO_INTEGER(LEG1_1 = 3 AND LEG1_2 = 5) R3_5,
TO_INTEGER(LEG1_1 = 3 AND LEG1_2 = 6) R3_6,
TO_INTEGER(LEG1_1 = 3 AND LEG1_2 > 6) R3_7,
TO_INTEGER(LEG1_1 > LEG1_2 AND LEG1_2 > 3 ) R4a_3a,
TO_INTEGER(LEG1_1 < LEG1_2 AND LEG1_1 > 3 ) R3a_4a
FROM MATCH_PAIR_CLEAN M;

